package com.sym.demo.jvm;

/**
 * @author suyongming
 * @date 2020/3/26 20:21
 */
public class Demo3 {
    public int math() {
        //0:  iconst_1 操作数栈 出现1
        //1:  istore_1 从操作数栈剪切到本地(局部)变量表                          {[1]:1}          本地(局部)变量表
        int   a = 1;
        //2:  iconst_2 操作数栈 出现2
        //3:  istore_2 从操作数栈剪切到本地(局部)变量表                          {[1]:1,[2]:2}    本地(局部)变量表
        int   b = 2;
        //4:  iload_1 把本地(局部)变量表[1]的值 压 到操作数栈                    {[1]:1}          操作数栈
        //5:  iload_2 把本地(局部)变量表[2]的值 压 到操作数栈                    {[1]:2,[2]:1}    操作数栈
        //6:  iadd 从操作数栈弹出来 a和b，再交给CPU寄存器进行计算                 {[1]:3}          操作数栈
        //7:  bipush 10  将单字节的常量值(-128~127)推送至栈顶                   {[1]:10,[2]:3}   操作数栈
        //    因为上面的10也是占用一个内存地址位子的，所以程序计数器的步骤8:就给省了
        //9:  imul     将栈顶两int型数值相乘并将结果压入操作数栈顶                {[1]:30}         操作数栈
        //10: istore_3 从操作数栈剪切到本地(局部)变量表                        {[1]:1,[2]:2,[3]:30}    本地(局部)变量表
        //11: iload_3  把本地(局部)变量表[3]的值 压 到操作数栈                 {[1]:30}         操作数栈
        int c = (a + b) * 10;
        //12: ireturn 从当前方法返回int  从方法出口中找到了调用者 main
        return c;
    }

    public static void main(String[] args) {
        Demo3 demo3 = new Demo3();
        demo3.math();
    }
}
